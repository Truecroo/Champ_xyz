<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>БЛЭСТ-селфи</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />

  <!-- jQuery -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

  <!-- THREE.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- OBJ/MTL loaders -->
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>

  <!-- MediaPipe FaceMesh -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

  <!-- ml5 PoseNet (fallback) -->
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

  <style>
    html, body {
      height:100%;
      margin:0;
      background:#000;
      color:#fff;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      overflow:hidden;
      overscroll-behavior:none;
      touch-action:none;
    }

    #permission-screen {
      position:fixed; inset:0;
      display:flex; flex-direction:column;
      align-items:center; justify-content:center;
      gap:16px; background:#000;
      z-index:10; padding:24px; text-align:center;
    }

    #button_loader, .downloadButton, .questionButton {
      padding:10px 16px;
      border:1px solid #fff;
      background:transparent;
      color:#fff;
      border-radius:8px;
      cursor:pointer;
    }

    #container {
      position:fixed; inset:0;
      display:none;
      touch-action:none;
    }

    #about {
      position:fixed;
      right:12px; bottom:12px;
    }

    #aboutText {
      display:none;
      position:fixed;
      right:12px; bottom:60px;
      width:260px;
      background:rgba(0,0,0,.7);
      padding:12px;
      border-radius:8px;
      font-size:13px;
      line-height:1.4;
    }

    #download_div {
      position:fixed;
      left:12px; bottom:12px;
      display:none;
    }

    #discription {
      position:fixed;
      top:12px; left:12px;
      background:rgba(0,0,0,.35);
      padding:8px 10px;
      border-radius:8px;
      font-size:13px;
    }

    /* Бренд-лоадер */
    #loading-screen {
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      background:#000;
      z-index:20;
    }

    .loader-card {
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:24px;
      text-align:center;
    }

    .loader-logo {
      width:164px;
      height:164px;
      object-fit:contain;
      image-rendering:auto;
    }

    .loader-text-main {
      font-size:20px;
      font-weight:600;
    }
    .loader-text-sub {
      font-size:16px;
      opacity:.8;
    }

    /* Статичный бренд-PNG — только с 3D-сценой */
    #brandBadge {
      position:fixed;
      right:12px;
      top:12px;
      width:120px;
      height:auto;
      z-index:15;
      pointer-events:none;
      display:none;
    }

    video {
      opacity:0;
      width:0; height:0;
      position:absolute; left:-9999px;
    }

    canvas { image-rendering:auto; }

    a { color:#9ad1ff; }
  </style>
</head>

<body>

  <!-- БРЕНД-ЛОАДЕР -->
  <div id="loading-screen" class="wrapper">
    <div class="loader-card">
      <img id="loading_logo" src="Loading_G.gif" alt="Загрузка…" class="loader-logo" />
      <div class="loader-text-main">Собираем кубы…</div>
      <div class="loader-text-sub">Подключаем камеру и трекаем лицо</div>
    </div>
  </div>

  <!-- Статичный PNG-логотип / инфа -->
  <img id="brandBadge" src="brand-cube.png" alt="Куб-селфи" />

  <section id="permission-screen">
    <div id="loader">
      <strong>Нужно разрешение на камеру</strong><br />
      Нажми «Продолжить» и в диалоге браузера выбери «Разрешить».<br />
      Видео никуда не сохраняется.
    </div>
    <button id="button_loader">Продолжить</button>
    <div style="opacity:.6; font-size:13px;">
      Если видишь «доступ запрещён» — открой настройки сайта в адресной строке и разреши камеру.
    </div>
  </section>

  <div id="container"></div>

  <!-- Текстурные канвасы -->
  <canvas id="canvas04" width="512" height="512" style="display:none"></canvas>  <!-- нос -->
  <canvas id="canvas01" width="512" height="512" style="display:none"></canvas>  <!-- правый глаз -->
  <canvas id="canvas02" width="512" height="256" style="display:none"></canvas>  <!-- рот -->
  <canvas id="Mycanvas" width="512" height="512" style="display:none"></canvas>  <!-- левый глаз -->

  <!-- Скрытое видео -->
  <video autoplay muted playsinline id="video" width="480" height="640"></video>

  <div id="discription">тап — перемешать кубы</div>

  <div id="about">
    <div id="aboutText">
      <p class="explain"><b>Придумано и сдеано БЛЭСТ ПРОД.</b> </p>
      <p class="credits">
        С помощью технологий:
        <a href="https://threejs.org/">Three.js</a>,
        <a href="https://developers.google.com/mediapipe/solutions/vision/face_mesh">MediaPipe FaceMesh</a>,
        <a href="https://learn.ml5js.org/#/reference/posenet">ml5 PoseNet</a>
      </p>
    </div>
    <button class="questionButton" id="aboutButton">Инфо</button>
  </div>

  <div id="download_div">
    <button class="downloadButton" id="download">Сделать снимок</button>
  </div>

<script>
  // ===== глушим скролл/свайпы страницы =====
  document.addEventListener('touchmove', e => e.preventDefault(), { passive:false });
  document.addEventListener('gesturestart', e => e.preventDefault(), { passive:false });

  // ===== DOM & helpers =====
  const video = document.getElementById("video");
  video.setAttribute('playsinline','true');
  video.setAttribute('muted','true');
  video.muted = true;

  const nose_canvas  = document.getElementById("canvas04"); const ctxNose  = nose_canvas.getContext("2d");
  const left_canvas  = document.getElementById("Mycanvas"); const ctxLEye  = left_canvas.getContext("2d");
  const right_canvas = document.getElementById("canvas01"); const ctxREye  = right_canvas.getContext("2d");
  const mouth_canvas = document.getElementById("canvas02"); const ctxMouth = mouth_canvas.getContext("2d");

  const brandBadge = document.getElementById("brandBadge");

  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const rand=(a,b)=>Math.random()*(b-a)+a;

  // ===== Three.js =====
  let scene, renderer;
  let camera, orthoCamera, activeCamera;
  let cube01, cube02, cube03, cube04;
  let headObject = null; // OBJ-голова
  let bgPlane = null;    // фон-плейн с текстом за головой

  const FIXED_Z = -140; // кубы ближе к камере

  // КАМЕРА: фиксированная орбита, без вращения
  let radius = 600;
  let azimuth = Math.PI / 2;   // камера на +Z
  let polar = Math.PI/2;
  const polarMin = Math.PI/6;
  const polarMax = Math.PI*5/6;
  let dragging = false, lastX=0, lastY=0, dragStartTime=0, moved=false;

  // ===== Лендмарки/боксы =====
  let firstPredictionCame = false;
  window._bbNose = null; window._bbLEye = null; window._bbREye = null; window._bbMouth = null;
  let noseX=0, noseY=0, leX=0, leY=0, reX=0, reY=0, mX=0, mY=0;

  // ===== UI =====
  $("#download").on("click", function(){
    if (!renderer) return;
    const srcCanvas = renderer.domElement;

    const capture = document.createElement("canvas");
    capture.width  = srcCanvas.width;
    capture.height = srcCanvas.height;
    const cctx = capture.getContext("2d");

    // 1) сцена
    cctx.drawImage(srcCanvas, 0, 0);

    // 2) бренд-оверлей (увеличенный)
    if (brandBadge && (brandBadge.naturalWidth || brandBadge.width)) {
      const bw = brandBadge.naturalWidth || brandBadge.width;
      const bh = brandBadge.naturalHeight || brandBadge.height || bw;

      const overlayW = capture.width * 0.22;
      const overlayH = overlayW * (bh / bw);
      const ox = capture.width - overlayW - 40;
      const oy = 40;

      try {
        cctx.drawImage(brandBadge, ox, oy, overlayW, overlayH);
      } catch(e){}
    }

    const dataURL = capture.toDataURL("image/png");
    const link = document.createElement("a");
    link.download = "selfie.png"; link.href = dataURL; link.target = "_blank"; link.click();
  });

  $("#aboutButton").on("click", function(){
    $("#aboutText").fadeToggle('fast');
    $("#aboutButton").text(($("#aboutButton").text() === 'Инфо') ? 'Закрыть' : 'Инфо').fadeIn();
  });

  $("#container, #discription").on('touchstart mousedown', function(){
    $("#discription").fadeOut('fast');
  });

  // ===== Камера + ошибки =====
  async function askCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio:false });
      video.srcObject = stream;

      if (video.readyState < 1) await new Promise(r => (video.onloadedmetadata = r));
      await video.play();

      await new Promise(r=>setTimeout(r,50));
      video.width  = video.videoWidth  || 480;
      video.height = video.videoHeight || 640;

      return true;
    } catch (err) {
      console.error('[getUserMedia error]', err.name, err.message);
      const hints = {
        NotAllowedError:    'Доступ к камере запрещён для этого сайта. Разреши камеру в настройках сайта и перезагрузи страницу.',
        NotFoundError:      'Камера не найдена. Подключи камеру или выбери её в настройках системы/браузера.',
        NotReadableError:   'Камера занята другим приложением. Закрой приложения, использующие камеру, и попробуй снова.',
        OverconstrainedError:'Выбранные параметры камеры недоступны. Попробуй стандартный режим.',
        SecurityError:      'Нужен HTTPS (или http://localhost).',
        TypeError:          'Неверные параметры запроса к камере.'
      };
      alert(hints[err.name] || ('Ошибка камеры: ' + err.message));
      return false;
    }
  }

  // ===== Кнопка «Продолжить» + ЛОАДЕР =====
  $("#button_loader").on("click", async function(){
    $("#permission-screen").fadeOut('slow');
    $("#loading-screen").css('display','flex');

    const ok = await askCamera();
    if (!ok) {
      $("#loading-screen").css('display','none');
      $("#permission-screen").show();
      return;
    }

    $("#container").fadeIn('slow');
    $("#download_div").fadeIn('slow');
    $("#aboutButton").fadeIn('slow');
    $("#brandBadge").fadeIn('slow');  // показываем бренд только вместе со сценой

    initThree();
    bootTrackers();
    changePosition();
    animate();

    setTimeout(()=>$("#loading-screen").fadeOut('fast'), 1600);
  });

  // ===== Трекеры =====
  function bootTrackers(){
    try {
      const fm = new FaceMesh.FaceMesh({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
      });
      fm.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      fm.onResults(onFaceMeshResults);
      let busy = false;
      (function pump(){
        if (!busy && video.videoWidth){
          busy = true;
          fm.send({ image: video }).catch(()=>{}).finally(()=>{ busy=false; });
        }
        requestAnimationFrame(pump);
      })();
    } catch(e) { console.warn('FaceMesh не запустился:', e); }

    try {
      const net = ml5.poseNet(video, () => {});
      net.on('pose', onPoseNetResults);
    } catch(e) { console.warn('PoseNet не запустился:', e); }
  }

  function onFaceMeshResults(res){
    const faces = res.multiFaceLandmarks || [];
    if (!faces.length) return;
    firstPredictionCame = true;

    const pts = faces[0];
    const IDX = {
      leftEye:  [33,133,160,159,158,157,173],
      rightEye: [362,263,387,386,385,384,398],
      nose:     [1,6,197,195,5,4,45],
      mouth:    [78,95,88,178,87,14,317,308,324]
    };

    function bboxNorm(idxs){
      let minX=1,minY=1,maxX=0,maxY=0;
      for (const i of idxs){
        const p=pts[i]; if(!p) continue; const x=p.x,y=p.y;
        if(x<minX)minX=x; if(y<minY)minY=y;
        if(x>maxX)maxX=x; if(y>maxY)maxY=y;
      }
      return {x:minX, y:minY, w:Math.max(1e-3,maxX-minX), h:Math.max(1e-3,maxY-minY)};
    }
    function toPixels(b, pad=0.03){
      const vw = video.videoWidth || video.width || 480;
      const vh = video.videoHeight || video.height || 640;
      const px = Math.max(0, b.x - pad) * vw;
      const py = Math.max(0, b.y - pad) * vh;
      const pw = Math.min(1, b.w + pad*2) * vw;
      const ph = Math.min(1, b.h + pad*2) * vh;
      return { x:px, y:py, w:pw, h:ph };
    }

    window._bbLEye  = toPixels(bboxNorm(IDX.leftEye),  0.04);
    window._bbREye  = toPixels(bboxNorm(IDX.rightEye), 0.04);
    window._bbNose  = toPixels(bboxNorm(IDX.nose),     0.05);
    window._bbMouth = toPixels(bboxNorm(IDX.mouth),    0.05);
  }

  function onPoseNetResults(res){
    if (!res || !res.length) return;
    const k = res[0].pose.keypoints;
    const nX = k[0].position.x, nY = k[0].position.y;
    const Lx = k[1].position.x, Ly = k[1].position.y;
    const Rx = k[2].position.x, Ry = k[2].position.y;

    const lerp=(a,b,t)=>a+(b-a)*Math.max(0,Math.min(1,t));
    noseX = lerp(noseX,nX,.5); noseY = lerp(noseY,nY,.5);
    leX   = lerp(leX  ,Lx,.5); leY   = lerp(leY  ,Ly,.5);
    reX   = lerp(reX  ,Rx,.5); reY   = lerp(reY  ,Ry,.5);

    const d = Math.hypot(noseX-leX, noseY-leY) || 120;
    mX = lerp(mX,noseX,.5); mY = lerp(mY,noseY + d,.5);

    const makeBox=(cx,cy,sz)=>({x:cx-sz/2, y:cy-sz/2, w:sz, h:sz});
    const sz = Math.max(40, Math.min(300, d));
    if (!firstPredictionCame) {
      window._bbNose  = makeBox(noseX, noseY, sz);
      window._bbLEye  = makeBox(leX,   leY,   sz);
      window._bbREye  = makeBox(reX,   reY,   sz);
      window._bbMouth = { x:mX - sz/2, y:mY - sz/2, w:sz, h:sz*0.5 };
    }
  }

  // ===== Three setup =====
  function initThree(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0b0b);

    renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    const aspect = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(35, aspect, 0.1, 2000);

    updateCameraFromSpherical();
    camera.lookAt(0,0,0);

    const frustumSize = 400;
    orthoCamera = new THREE.OrthographicCamera(
      -frustumSize*aspect/2, frustumSize*aspect/2,
       frustumSize/2, -frustumSize/2,
       0.1, 2000
    );
    activeCamera = camera;

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(300, 400, 500);
    scene.add(dir);

    // ==== ПЛОСКОСТЬ С ТЕКСТОМ ЗА ГОЛОВОЙ ====
    const texLoader = new THREE.TextureLoader();
    texLoader.load('bg-text.png', function(tex){
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

      const bgMat = new THREE.MeshBasicMaterial({
        map: tex,
        transparent: true,
        depthWrite: true,
        depthTest: true
      });

      // подгон под 1920x1080 (16:9)
      const BG_W = 1600;
      const BG_H = BG_W * 1080 / 1920; // 900

      const bgGeo = new THREE.PlaneGeometry(BG_W, BG_H);
      bgPlane = new THREE.Mesh(bgGeo, bgMat);

      // по центру за головой
      bgPlane.position.set(0, 0, -1000);
      scene.add(bgPlane);
    });

    // текстуры с канвасов
    const texNose  = new THREE.CanvasTexture(nose_canvas);
    const texLEye  = new THREE.CanvasTexture(left_canvas);
    const texREye  = new THREE.CanvasTexture(right_canvas);
    const texMouth = new THREE.CanvasTexture(mouth_canvas);

    const matNose  = new THREE.MeshBasicMaterial({ map: texNose });
    const matLEye  = new THREE.MeshBasicMaterial({ map: texLEye });
    const matREye  = new THREE.MeshBasicMaterial({ map: texREye });
    const matMouth = new THREE.MeshBasicMaterial({ map: texMouth });

    // порядок граней: [ +X, -X, +Y, -Y, +Z, -Z ]
    // фронт при старте — +Z (index 4), камера на +Z, смотрит в центр

    // cube01 — НОС
    cube01 = new THREE.Mesh(
      new THREE.BoxGeometry(40, 60, 40),
      [
        matLEye,   // +X
        matREye,   // -X
        matMouth,  // +Y
        matMouth,  // -Y
        matNose,   // +Z фронт
        matLEye    // -Z
      ]
    );

    // cube02 — ЛЕВЫЙ ГЛАЗ
    cube02 = new THREE.Mesh(
      new THREE.BoxGeometry(50, 50, 50),
      [
        matNose,   // +X
        matMouth,  // -X
        matREye,   // +Y
        matNose,   // -Y
        matLEye,   // +Z фронт
        matMouth   // -Z
      ]
    );

    // cube03 — ПРАВЫЙ ГЛАЗ
    cube03 = new THREE.Mesh(
      new THREE.BoxGeometry(50, 50, 50),
      [
        matMouth,  // +X
        matNose,   // -X
        matLEye,   // +Y
        matMouth,  // -Y
        matREye,   // +Z фронт
        matNose    // -Z
      ]
    );

    // cube04 — РОТ
    cube04 = new THREE.Mesh(
      new THREE.BoxGeometry(100, 35, 35),
      [
        matREye,   // +X
        matLEye,   // -X
        matNose,   // +Y
        matNose,   // -Y
        matMouth,  // +Z фронт
        matLEye    // -Z
      ]
    );

    const baseRotY = THREE.Math.degToRad(-10);
    [cube01, cube02, cube03, cube04].forEach(c=>{
      c.rotation.set(0, baseRotY, 0);
      c.position.z = FIXED_Z;
      scene.add(c);
    });

    // грузим OBJ-голову (фон)
    loadHeadModel();

    window.addEventListener('resize', onResize);

    // Жесты: только для тапа (перемешивание), без вращения камеры
    document.addEventListener('pointerdown', e=>{
      dragging=true; moved=false; dragStartTime=Date.now();
      lastX=e.clientX; lastY=e.clientY;
    }, {passive:true});

    document.addEventListener('pointermove', e=>{
      if(!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      if (Math.abs(dx)>2 || Math.abs(dy)>2) moved=true;
      lastX = e.clientX; lastY = e.clientY;
    }, {passive:true});

    document.addEventListener('pointerup', e=>{
      if(!dragging) return;
      const tap = !moved && (Date.now()-dragStartTime < 250);
      dragging=false;
      if (tap) onTap(e);
    }, {passive:true});
  }

  // ===== Загрузка OBJ-головы =====
  function loadHeadModel(){
    try {
      const mtlLoader = new THREE.MTLLoader();
      mtlLoader.setPath('./');

      mtlLoader.load(
        'head.mtl',
        function(materials){
          materials.preload();

          const objLoader = new THREE.OBJLoader();
          objLoader.setMaterials(materials);
          objLoader.setPath('./');

          objLoader.load(
            'head.obj',
            function(obj){
              setupHeadObject(obj);
            },
            undefined,
            function(err){
              console.warn('OBJ load error', err);
            }
          );
        },
        undefined,
        function(err){
          console.warn('MTL load error', err);
        }
      );
    } catch(e){
      console.warn('MTL/OBJ loader error', e);
    }
  }

  function setupHeadObject(obj){
    headObject = obj;

    headObject.traverse(function(child){
      if (child.isMesh) {
        if (child.geometry && child.geometry.center) {
          child.geometry.computeBoundingBox();
          child.geometry.center();
        }

        // жёстко серый материал, не надеемся на mtl
        child.material = new THREE.MeshStandardMaterial({
          color: 0x777777,
          metalness: 0.05,
          roughness: 0.9
        });

        child.castShadow = false;
        child.receiveShadow = false;
      }
    });

    const box = new THREE.Box3().setFromObject(headObject);
    const size = new THREE.Vector3();
    box.getSize(size);

    if (size.y > 0) {
      const targetHeight = 550;
      const s = targetHeight / size.y;
      headObject.scale.set(s, s, s);
    }

    headObject.position.set(0, 0, -700);
    scene.add(headObject);
  }

  // фиксированная камера
  function updateCameraFromSpherical(){
    const sinP = Math.sin(polar), cosP = Math.cos(polar);
    const sinA = Math.sin(azimuth), cosA = Math.cos(azimuth);
    const x = radius * sinP * cosA;
    const y = radius * cosP;
    const z = radius * sinP * sinA;
    if (camera) {
      camera.position.set(x,y,z);
      camera.lookAt(0,0,0);
    }
  }

  // Рандом с вертикальной логикой
  function changePosition(){
    const F = (a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
    let guard = 0, ok = false;

    while(!ok && guard < 200){
      guard++;

      // НОС — центр
      cube01.position.set(
        rand(-12, 12),
        rand(10, 28),
        FIXED_Z
      );

      // ЛЕВЫЙ ГЛАЗ — твои координаты
      cube02.position.set(
        rand(55, 20),
        rand(70, 105),
        FIXED_Z
      );

      // ПРАВЫЙ ГЛАЗ — твои координаты
      cube03.position.set(
        rand(-20, -55),
        rand(70, 105),
        FIXED_Z
      );

      // РОТ — твои координаты
      cube04.position.set(
        rand(-35, 35),
        rand(-55, -25),
        FIXED_Z
      );

      const p = [cube01.position, cube02.position, cube03.position, cube04.position];
      ok = true;
      for(let i=0;i<p.length;i++){
        for(let j=i+1;j<p.length;j++){
          if (F(p[i], p[j]) < 85) {
            ok = false;
            break;
          }
        }
        if(!ok) break;
      }
    }

    // базовые Y для флотинга
    cube01.userData.baseY = cube01.position.y;
    cube02.userData.baseY = cube02.position.y;
    cube03.userData.baseY = cube03.position.y;
    cube04.userData.baseY = cube04.position.y;
  }

  function onResize(){
    const w = window.innerWidth, h = window.innerHeight, aspect = w/h;
    if (camera) {
      camera.aspect = aspect; camera.updateProjectionMatrix();
    }

    const frustumSize = 400;
    if (orthoCamera) {
      orthoCamera.left = -frustumSize*aspect/2;
      orthoCamera.right =  frustumSize*aspect/2;
      orthoCamera.top =    frustumSize/2;
      orthoCamera.bottom = -frustumSize/2;
      orthoCamera.updateProjectionMatrix();
    }

    if (renderer) renderer.setSize(w,h);
    updateCameraFromSpherical();
  }

  function onTap(e){
    const downloadRect = document.getElementById("download_div").getBoundingClientRect();
    const aboutRect    = document.getElementById("aboutButton").getBoundingClientRect();
    const x = e.pageX || e.clientX, y = e.pageY || e.clientY;
    const inDownload = x >= downloadRect.left-5 && x <= downloadRect.right+5 &&
                       y >= downloadRect.top-5  && y <= downloadRect.bottom+5;
    const inAbout    = x >= aboutRect.left-5    && x <= aboutRect.right+5 &&
                       y >= aboutRect.top-5     && y <= aboutRect.bottom+5;
    if (inDownload || inAbout) return;
    changePosition();
  }

  // ===== Рендер/нарезка =====
  function drawFull(dstCtx, dw, dh){
    try {
      dstCtx.drawImage(
        video,
        0, 0,
        video.videoWidth || dw,
        video.videoHeight || dh,
        0, 0, dw, dh
      );
    } catch(e){}
  }

  function drawCrop(dstCtx, b, dw, dh, zoom){
    if (!b || !Number.isFinite(b.x) || !Number.isFinite(b.y)) {
      drawFull(dstCtx, dw, dh);
      return;
    }

    const vw = video.videoWidth || video.width || 480;
    const vh = video.videoHeight || video.height || 640;

    const ZOOM_OUT = zoom || 1.3;

    const cx = b.x + b.w / 2;
    const cy = b.y + b.h / 2;

    let sw = b.w * ZOOM_OUT;
    let sh = b.h * ZOOM_OUT;

    let sx = cx - sw / 2;
    let sy = cy - sh / 2;

    sx = clamp(sx, 0, vw - 1);
    sy = clamp(sy, 0, vh - 1);
    sw = clamp(sw, 1, vw - sx);
    sh = clamp(sh, 1, vh - sy);

    try {
      dstCtx.drawImage(video, sx, sy, sw, sh, 0, 0, dw, dh);
    } catch(e){}
  }

  function animate(){
    requestAnimationFrame(animate);

    const hasLM = (_bbNose || _bbLEye || _bbREye || _bbMouth);
    if (hasLM) {
      drawCrop(ctxNose,  _bbNose,  nose_canvas.width,  nose_canvas.height, 0.9);
      drawCrop(ctxLEye,  _bbLEye,  left_canvas.width,  left_canvas.height);
      drawCrop(ctxREye,  _bbREye,  right_canvas.width, right_canvas.height);
      drawCrop(ctxMouth, _bbMouth, mouth_canvas.width, mouth_canvas.height, 1.5);
    } else {
      drawFull(ctxNose,  nose_canvas.width,  nose_canvas.height);
      drawFull(ctxLEye,  left_canvas.width,  left_canvas.height);
      drawFull(ctxREye,  right_canvas.width, right_canvas.height);
      drawFull(ctxMouth, mouth_canvas.width, mouth_canvas.height);
    }

    [cube01, cube02, cube03, cube04].forEach(cube => {
      if (cube && cube.material) {
        if (Array.isArray(cube.material)) {
          cube.material.forEach(mat => {
            if (mat.map) mat.map.needsUpdate = true;
          });
        } else if (cube.material.map) {
          cube.material.map.needsUpdate = true;
        }
      }
    });

    const t = performance.now() * 0.001;

    if (cube01 && cube01.userData.baseY !== undefined) {
      cube01.position.y = cube01.userData.baseY + Math.sin(t * 0.8 + 0.0) * 6;
    }
    if (cube02 && cube02.userData.baseY !== undefined) {
      cube02.position.y = cube02.userData.baseY + Math.sin(t * 0.9 + 1.3) * 5;
    }
    if (cube03 && cube03.userData.baseY !== undefined) {
      cube03.position.y = cube03.userData.baseY + Math.sin(t * 1.0 + 2.1) * 5;
    }
    if (cube04 && cube04.userData.baseY !== undefined) {
      cube04.position.y = cube04.userData.baseY + Math.sin(t * 0.7 + 3.4) * 7;
    }

    if (activeCamera && renderer && scene) {
      activeCamera.lookAt(0,0,0);
      renderer.render(scene, activeCamera);
    }
  }
</script>
</body>
</html>
