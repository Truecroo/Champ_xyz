<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Selfie Cubes — камера → 3D кубы</title>

  <!-- three.js -->
  <script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

  <!-- TFJS + PoseNet + ml5 -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.18.0/dist/tf.min.js"></script>
  <script src="https://unpkg.com/@tensorflow-models/posenet@2.2.2/dist/posenet.min.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; background:#000; color:#fff;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #app { position: fixed; inset: 0; display: grid; grid-template-rows: auto 1fr auto; }
    header { display:flex; align-items:center; justify-content:space-between; padding:12px 16px;
      border-bottom:1px solid #171717; background:rgba(0,0,0,.4); backdrop-filter:blur(6px); }
    header h1 { margin:0; font-size:14px; font-weight:600; opacity:.9; }
    main { position: relative; }
    #container { position:absolute; inset:0; }
    footer { display:flex; gap:8px; justify-content:center; align-items:center; padding:16px; }
    .btn { appearance:none; border:1px solid #333; background:#0f0f0f; color:#fff;
      padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; }
    .btn.primary { background:#fff; color:#000; border-color:#fff; }
    #status { font-size:12px; opacity:.85; text-align:center; padding:6px 12px; }
    #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.85); }
    .card { background:#0d0d0d; border:1px solid #222; border-radius:14px; padding:16px; max-width:520px; text-align:center; }
    .card h2 { margin:0 0 8px; font-size:18px; }
    .note { font-size:12px; opacity:.85; }
    video { position: fixed; left:-9999px; width:0; height:0; opacity:0; }
    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }
  </style>
</head>
<body>
<div id="app">
  <header>
    <h1>Selfie Cubes · PoseNet + Three.js</h1>
    <button id="btnInfo" class="btn" title="Информация">Инфо</button>
  </header>

  <main>
    <div id="container" aria-label="3D полотно"></div>

    <div id="overlay" role="dialog" aria-modal="true">
      <div class="card">
        <h2>Дай доступ к камере</h2>
        <p>Мы собираем кубики из видео с фронталки. Ничего никуда не отправляется — всё локально в браузере.</p>
        <p class="note">Если открыл через встроенный браузер (Telegram/IG/VK) — «Открыть в браузере», затем Safari/Chrome.</p>
        <div style="display:flex; gap:8px; justify-content:center; margin-top:12px;">
          <button id="btnStart" class="btn primary">Разрешить камеру</button>
        </div>
      </div>
    </div>

    <!-- скрытые поверхности для текстур -->
    <video id="video" autoplay playsinline muted></video>
    <canvas id="cNose"  width="300" height="300" class="sr-only"></canvas>
    <canvas id="cEyeL"  width="300" height="300" class="sr-only"></canvas>
    <canvas id="cEyeR"  width="300" height="300" class="sr-only"></canvas>
    <canvas id="cMouth" width="300" height="150" class="sr-only"></canvas>
  </main>

  <footer>
    <button id="btnShuffle" class="btn">Перемешать</button>
    <button id="btnCapture" class="btn primary">Снимок</button>
  </footer>
</div>

<p id="status" aria-live="polite"></p>

<script>
/* ===== helpers ===== */
const $ = s => document.querySelector(s);
const on = (el, ev, cb) => el.addEventListener(ev, cb);
const log = m => { $('#status').textContent = m; };
const lerp = (a,b,t)=>a+(b-a)*Math.max(0,Math.min(1,t));
const dist = (x1,y1,x2,y2)=>Math.hypot(x1-x2,y1-y2);

/* ===== state ===== */
let video = $('#video'), stream=null;
let scene, camera, renderer, controls;
let texNose, texEyeL, texEyeR, texMouth;
let cubeNose, cubeEyeL, cubeEyeR, cubeMouth;
let noseX=0,noseY=0,leX=0,leY=0,reX=0,reY=0,mX=0,mY=0;
let started=false;

/* canvases */
const cNose=$('#cNose'), cEyeL=$('#cEyeL'), cEyeR=$('#cEyeR'), cMouth=$('#cMouth');
const ctxN=cNose.getContext('2d'), ctxL=cEyeL.getContext('2d'),
      ctxR=cEyeR.getContext('2d'), ctxM=cMouth.getContext('2d');

/* ===== UI ===== */
on($('#btnInfo'), 'click', ()=> alert('Selfie Cubes: нос/глаза/рот вырезаются из видео и мапятся на 3D-кубы. Все вычисления локально.'));

on($('#btnStart'), 'click', async ()=>{
  try{
    if(location.protocol!=='https:' && location.hostname!=='localhost'){
      alert('Нужен HTTPS. Открой через https:// (на Vercel он уже есть).'); return;
    }
    log('Запрашиваем камеру…');
    stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:{ ideal:'user' } }, audio:false });
    video.srcObject = stream; await video.play();

    // ✅ важное: выставляем реальные размеры — PoseNet использует координаты видео
    await new Promise(r=>setTimeout(r,50));
    const vw = video.videoWidth || 480, vh = video.videoHeight || 640;
    video.width = vw; video.height = vh;

    $('#overlay').style.display='none';
    log('Камера ок. Загружаем PoseNet…');
    boot();
  }catch(err){
    alert(`Ошибка камеры: ${err.name} — ${err.message}`);
    console.error(err); log('Доступ отклонён. Разреши камеру в настройках сайта/браузера.');
  }
});

on($('#btnCapture'), 'click', ()=>{
  if(!renderer) return;
  const a=document.createElement('a');
  a.href=renderer.domElement.toDataURL('image/png'); a.download='selfie.png'; a.click();
});

on($('#btnShuffle'), 'click', ()=> shuffleCubes());

/* тап без перетаскивания = перемешать (как в оригинале) */
let dragging=false;
const containerEl = document.getElementById('container');
containerEl.addEventListener('pointerdown', ()=> dragging=false);
containerEl.addEventListener('pointermove', ()=> dragging=true);
containerEl.addEventListener('pointerup', ()=>{ if(!dragging) shuffleCubes(); });

/* ===== three.js ===== */
function initThree(){
  const WIDTH=innerWidth, HEIGHT=innerHeight;
  scene = new THREE.Scene();
  renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
  renderer.setPixelRatio(devicePixelRatio||1); renderer.setSize(WIDTH,HEIGHT);
  document.getElementById('container').appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(35, WIDTH/HEIGHT, 1, 2000);
  camera.position.set(0,0,281);

  import('https://unpkg.com/three@0.157.0/examples/jsm/controls/OrbitControls.js')
    .then(mod=>{
      const OrbitControls = mod.OrbitControls;
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enablePan=false; controls.enableZoom=false; controls.rotateSpeed=1.0;
      controls.minDistance=600; controls.maxDistance=600;
    });

  scene.fog = new THREE.Fog(0xFFFFFF,1,25000);
  scene.add(new THREE.HemisphereLight(0xffffff,0xffffff,0.8));
  const dir = new THREE.DirectionalLight(0xffffff,0.4); dir.position.set(-3000,4000,3000); scene.add(dir);

  texNose  = new THREE.CanvasTexture(cNose);
  texEyeL  = new THREE.CanvasTexture(cEyeL);
  texEyeR  = new THREE.CanvasTexture(cEyeR);
  texMouth = new THREE.CanvasTexture(cMouth);

  cubeNose = new THREE.Mesh(new THREE.BoxGeometry(50,80,50),  new THREE.MeshBasicMaterial({ map: texNose  }));
  cubeEyeL = new THREE.Mesh(new THREE.BoxGeometry(50,50,50),  new THREE.MeshBasicMaterial({ map: texEyeL  }));
  cubeEyeR = new THREE.Mesh(new THREE.BoxGeometry(50,50,50),  new THREE.MeshBasicMaterial({ map: texEyeR  }));
  cubeMouth= new THREE.Mesh(new THREE.BoxGeometry(100,45,45), new THREE.MeshBasicMaterial({ map: texMouth }));

  scene.add(cubeNose, cubeEyeL, cubeEyeR, cubeMouth);
  shuffleCubes();

  addEventListener('resize', ()=>{
    const W=innerWidth,H=innerHeight;
    renderer.setSize(W,H); camera.aspect=W/H; camera.updateProjectionMatrix();
  });
}

function shuffleCubes(){
  const rnd=(a,b)=>Math.random()*(b-a)+a;
  cubeNose.position.set(rnd(-55,55),  rnd(-140,140), 0); cubeNose.rotation.y = rnd(0.1,0.5);
  cubeEyeL.position.set(rnd(-50,50),  rnd(-150,150), 0); cubeEyeL.rotation.y = rnd(0.1,0.5);
  cubeEyeR.position.set(rnd(-50,50),  rnd(-150,150), 0); cubeEyeR.rotation.y = rnd(0.1,0.5);
  cubeMouth.position.set(rnd(-45,45), rnd(-155,155), 0); cubeMouth.rotation.y = rnd(0.1,0.5);
}

/* ===== PoseNet ===== */
function startPoseNet(){
  const net = ml5.poseNet(video, ()=> log('PoseNet готов'));
  net.on('pose', (res)=>{
    if(!res.length) return;
    const k = res[0].pose.keypoints;
    const nX = k[0].position.x, nY = k[0].position.y;   // nose
    const Lx = k[1].position.x, Ly = k[1].position.y;   // left eye
    const Rx = k[2].position.x, Ry = k[2].position.y;   // right eye
    noseX=lerp(noseX,nX,.5); noseY=lerp(noseY,nY,.5);
    leX =lerp(leX ,Lx,.5); leY=lerp(leY,Ly,.5);
    reX =lerp(reX ,Rx,.5); reY=lerp(reY,Ry,.5);
    const d = dist(noseX,noseY,leX,leY);
    mX = lerp(mX,nX,.5); mY = lerp(mY,nY + d,.5);       // mouth ≈ nose + d вниз
  });
}

/* ===== render loop ===== */
function loop(){
  requestAnimationFrame(loop);

  const d = dist(noseX,noseY,leX,leY) || 120;
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const vw=video.width||video.videoWidth||480, vh=video.height||video.videoHeight||640;

  const safe = (sx,sy,sw,sh)=>{
    const x=clamp(sx,0,vw-1), y=clamp(sy,0,vh-1);
    const w=clamp(sw,1,vw-x), h=clamp(sh,1,vh-y);
    return {x,y,w,h};
  };

  try{
    let r;
    r=safe(noseX-d/2, noseY-d/2, d+0.01, d+0.01); ctxN.drawImage(video,r.x,r.y,r.w,r.h, 0,0,300,300);
    r=safe(leX  -d/2, leY  -d/2, d+0.01, d+0.01); ctxL.drawImage(video,r.x,r.y,r.w,r.h, 0,0,300,300);
    r=safe(reX  -d/2, reY  -d/2, d+0.01, d+0.01); ctxR.drawImage(video,r.x,r.y,r.w,r.h, 0,0,300,300);
    r=safe(mX   -d/2, mY   -d/2, d+0.01, d+0.01); ctxM.drawImage(video,r.x,r.y,r.w,r.h, 0,0,300,150);
  }catch(e){ /* ждём первый апдейт позы */ }

  // лёгкая авто-ротация — «кубы крутятся»
  if(cubeNose)  cubeNose.rotation.y  += 0.003;
  if(cubeEyeL)  cubeEyeL.rotation.y  += 0.0035;
  if(cubeEyeR)  cubeEyeR.rotation.y  += 0.0025;
  if(cubeMouth) cubeMouth.rotation.y += 0.0028;

  if(texNose)  texNose.needsUpdate = true;
  if(texEyeL)  texEyeL.needsUpdate = true;
  if(texEyeR)  texEyeR.needsUpdate = true;
  if(texMouth) texMouth.needsUpdate = true;

  if(renderer && camera && scene){ camera.lookAt(scene.position); renderer.render(scene,camera); controls && controls.update(); }
}

/* ===== boot ===== */
function boot(){
  if(started) return; started = true;
  initThree();
  startPoseNet();
  loop();
}
</script>
</body>
</html>
