<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Куб-селфи</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />

  <!-- Библиотеки (оставляем как в текущей версии) -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

  <!-- THREE r128 + OrbitControls под ту же версию -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>

  <!-- TFJS + MediaPipe FaceMesh + ml5 (ml5 даёт и facemesh, и posenet) -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
  <script src="https://unpkg.com/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

  <link rel="stylesheet" href="selfie.css" />
  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }
    html, body { height:100%; margin:0; background:#000; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #app { position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto; }
    header { display:flex; align-items:center; justify-content:space-between; padding:12px 16px; border-bottom:1px solid #171717; background:rgba(0,0,0,.4); backdrop-filter:blur(6px); }
    header h1 { margin:0; font-size:14px; font-weight:600; opacity:.9; }
    main { position:relative; }
    #container { position:absolute; inset:0; }
    #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,.85); z-index:2; }
    .card { background:#0d0d0d; border:1px solid #222; border-radius:14px; padding:16px; max-width:520px; text-align:center; }
    .card h2 { margin:0 0 8px; font-size:18px; }
    .note { font-size:12px; opacity:.8; }
    footer { display:flex; gap:8px; justify-content:center; align-items:center; padding:16px; }
    .btn { appearance:none; border:1px solid #333; background:#0f0f0f; color:#fff; padding:10px 14px; border-radius:10px; font-weight:600; cursor:pointer; }
    .btn.primary { background:#fff; color:#000; border-color:#fff; }
    #status { font-size:12px; opacity:.85; text-align:center; padding:6px 12px; }
    video { position:fixed; left:-9999px; width:0; height:0; opacity:0; }
    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); border:0; }
  </style>
</head>
<body>
<div id="app">
  <header>
    <h1>Selfie Cubes · FaceMesh↔PoseNet fallback</h1>
    <button id="btnInfo" class="btn">Инфо</button>
  </header>

  <main>
    <div id="container" aria-label="3D полотно"></div>

    <div id="overlay" role="dialog" aria-modal="true">
      <div class="card">
        <h2>Дай доступ к камере</h2>
        <p>Берём фрагменты лица (нос/глаза/рот) и мапим на 3D-кубы в реальном времени. Всё локально в браузере.</p>
        <p class="note">Если открыт во встроенном браузере (Telegram/IG/VK) — нажми «Открыть в браузере» и используй Safari/Chrome.</p>
        <div style="display:flex; gap:8px; justify-content:center; margin-top:12px;">
          <button id="btnStart" class="btn primary">Разрешить камеру</button>
        </div>
      </div>
    </div>

    <!-- скрытые поверхности для текстур -->
    <video id="video" autoplay playsinline muted></video>
    <canvas id="cNose"  width="512" height="512" class="sr-only"></canvas>
    <canvas id="cEyeL"  width="512" height="512" class="sr-only"></canvas>
    <canvas id="cEyeR"  width="512" height="512" class="sr-only"></canvas>
    <canvas id="cMouth" width="512" height="256" class="sr-only"></canvas>
  </main>

  <footer>
    <button id="btnShuffle" class="btn">Перемешать</button>
    <button id="btnCapture" class="btn primary">Снимок</button>
  </footer>
</div>

<p id="status" aria-live="polite"></p>

<script>
/* ============ утилиты ============ */
const $ = s => document.querySelector(s);
const on = (el,ev,cb)=> el.addEventListener(ev,cb);
const log = m => { $('#status').textContent = m; };
const lerp=(a,b,t)=>a+(b-a)*Math.max(0,Math.min(1,t));
const dist=(x1,y1,x2,y2)=>Math.hypot(x1-x2,y1-y2);
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

/* ============ DOM/канвасы ============ */
const video = $('#video');
video.setAttribute('playsinline','true');
video.setAttribute('muted','true'); video.muted = true;

const cNose=$('#cNose'), cEyeL=$('#cEyeL'), cEyeR=$('#cEyeR'), cMouth=$('#cMouth');
const ctxN=cNose.getContext('2d'), ctxL=cEyeL.getContext('2d'),
      ctxR=cEyeR.getContext('2d'), ctxM=cMouth.getContext('2d');

/* ============ three.js ============ */
let scene, camera, renderer, controls;
let cubeNose, cubeEyeL, cubeEyeR, cubeMouth;
let texNose, texEyeL, texEyeR, texMouth;
const FIXED_Z = 0;

/* ============ tracking state ============ */
let trackingMode = 'facemesh'; // 'facemesh' | 'posenet'
let firstPrediction = false;

let noseX=0, noseY=0, leX=0, leY=0, reX=0, reY=0, mX=0, mY=0; // для posenet
let LM = { nose:null, lEye:null, rEye:null, mouth:null };    // для facemesh (bbox)

/* ============ UI ============ */
on($('#btnInfo'),'click',()=> alert('Тап — перемешать кубы. Свайп/drag — вращать сцену. «Снимок» сохранит PNG. Все вычисления на устройстве.'));
on($('#btnCapture'),'click', ()=>{
  if (!renderer) return;
  const a=document.createElement('a');
  a.href = renderer.domElement.toDataURL('image/png');
  a.download='selfie.png'; a.click();
});
on($('#btnShuffle'),'click', ()=> changePosition());

let drag=false;
on(document,'pointerdown',()=>{ drag=false; });
on(document,'pointermove',()=>{ drag=true; });
on(document,'pointerup',(e)=>{
  if (e.target.closest('button')) return;
  if (!drag) changePosition();
});

/* ============ запуск камеры ============ */
on($('#btnStart'),'click', startCamera);

async function startCamera(){
  try{
    if (location.protocol!=='https:' && location.hostname!=='localhost'){
      alert('Нужен HTTPS. Открой по https:// (на Vercel он уже есть).'); return;
    }
    log('Запрашиваем камеру…');
    const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode: 'user' }, audio:false });
    video.srcObject = stream;

    if (video.readyState < 1) await new Promise(r => (video.onloadedmetadata = r));
    await video.play();

    // зафиксировать размеры — важно для кропа
    await new Promise(r=>setTimeout(r,50));
    video.width  = video.videoWidth  || 480;
    video.height = video.videoHeight || 640;

    $('#overlay').style.display='none';
    log('Камера ок. Загружаем FaceMesh…');

    boot(); // three + tracking + loop
  }catch(err){
    console.error(err);
    alert(`Ошибка камеры: ${err.name} — ${err.message}`);
    log('Доступ к камере отклонён. Разреши камеру в настройках сайта/браузера.');
  }
}

/* ============ three init ============ */
function initThree(){
  const WIDTH=innerWidth, HEIGHT=innerHeight;
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b0b0b);

  renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
  renderer.setPixelRatio(devicePixelRatio||1);
  renderer.setSize(WIDTH,HEIGHT);
  document.getElementById('container').appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(35, WIDTH/HEIGHT, 1, 2000);
  camera.position.set(0,0,300);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enablePan=false; controls.enableZoom=false; controls.enableRotate=true; controls.rotateSpeed=1.0;

  // Свет
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(300,400,500); scene.add(dir);

  // Текстуры
  texNose  = new THREE.CanvasTexture(cNose);
  texEyeL  = new THREE.CanvasTexture(cEyeL);
  texEyeR  = new THREE.CanvasTexture(cEyeR);
  texMouth = new THREE.CanvasTexture(cMouth);

  // Кубы
  cubeNose = new THREE.Mesh(new THREE.BoxGeometry(70, 90, 70),  new THREE.MeshBasicMaterial({ map: texNose  }));
  cubeEyeL = new THREE.Mesh(new THREE.BoxGeometry(60, 60, 60),  new THREE.MeshBasicMaterial({ map: texEyeL  }));
  cubeEyeR = new THREE.Mesh(new THREE.BoxGeometry(60, 60, 60),  new THREE.MeshBasicMaterial({ map: texEyeR  }));
  cubeMouth= new THREE.Mesh(new THREE.BoxGeometry(120,55, 55),  new THREE.MeshBasicMaterial({ map: texMouth }));

  [cubeNose, cubeEyeL, cubeEyeR, cubeMouth].forEach(c=>{
    c.rotation.set(0,0,0);
    c.position.z = FIXED_Z;
    scene.add(c);
  });

  changePosition(); // стартовые позиции

  addEventListener('resize', ()=>{
    const W=innerWidth, H=innerHeight;
    renderer.setSize(W,H); camera.aspect=W/H; camera.updateProjectionMatrix();
  });
}

/* ============ позиции кубов (из твоего кода) ============ */
function rand(a,b){ return Math.random()*(b-a)+a; }
function changePosition(){
  let d1=0,d2=0,d3=0,d4=0,d5=0,d6=0;
  do {
    cubeNose.rotation.y  = rand(0.1,0.5);
    cubeEyeL.rotation.y  = rand(0.1,0.5);
    cubeEyeR.rotation.y  = rand(0.1,0.5);
    cubeMouth.rotation.y = rand(0.1,0.5);

    cubeNose.position.set(rand(-55,55),  rand(-120,120), 0);
    cubeEyeL.position.set(rand(-70,70),  rand(-110,110), 0);
    cubeEyeR.position.set(rand(-70,70),  rand(-110,110), 0);
    cubeMouth.position.set(rand(-60,60), rand(-120,120), 0);

    const p01=cubeNose.position, p02=cubeEyeL.position, p03=cubeEyeR.position, p04=cubeMouth.position;
    const f=(a,b)=>Math.hypot(a.x-b.x, a.y-b.y);
    d1=f(p01,p02); d2=f(p02,p03); d3=f(p01,p03); d4=f(p03,p04); d5=f(p02,p04); d6=f(p01,p04);
  } while (d1<100 || d2<100 || d3<100 || d4<100 || d5<100 || d6<100);
}

/* ============ FaceMesh первично ============ */
function startFaceMesh(){
  try{
    const model = ml5.faceMesh(video, ()=> log('FaceMesh готов'));
    model.on('predict', results=>{
      if (!results || !results.length) return;
      firstPrediction = true;
      const pts = results[0].scaledMesh;

      // индексы из медиапайпа
      const leftEyeIdx = [33,133,160,159,158,157,173];
      const rightEyeIdx= [362,263,387,386,385,384,398];
      const noseIdx    = [1,6,197,195,5,4,45];
      const mouthIdx   = [78,95,88,178,87,14,317,308,324];

      const bbox = (idxs)=>{
        let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
        for(const i of idxs){ const p=pts[i]; if(!p) continue; const x=p[0], y=p[1];
          if(x<minX) minX=x; if(y<minY) minY=y; if(x>maxX) maxX=x; if(y>maxY) maxY=y;
        }
        return {x:minX,y:minY,w:Math.max(1,maxX-minX),h:Math.max(1,maxY-minY)};
      };
      const pad=(b,p=10)=>({x:b.x-p,y:b.y-p,w:b.w+2*p,h:b.h+2*p});

      LM.nose  = pad(bbox(noseIdx), 10);
      LM.lEye  = pad(bbox(leftEyeIdx), 10);
      LM.rEye  = pad(bbox(rightEyeIdx), 10);
      LM.mouth = pad(bbox(mouthIdx), 12);
    });

    // страховка: если 3 сек нет предиктов — уходим в posenet
    setTimeout(()=>{
      if (!firstPrediction){
        console.warn('FaceMesh молчит >3s → fallback на PoseNet');
        trackingMode = 'posenet';
        startPoseNet();
      }
    }, 3000);
  }catch(e){
    console.warn('FaceMesh не инициализировался:', e);
    trackingMode = 'posenet';
    startPoseNet();
  }
}

/* ============ PoseNet как fallback ============ */
function startPoseNet(){
  const net = ml5.poseNet(video, ()=> log('PoseNet готов'));
  net.on('pose',(res)=>{
    if(!res.length) return;
    firstPrediction = true;
    const k = res[0].pose.keypoints;
    const nX = k[0].position.x, nY = k[0].position.y;   // нос
    const Lx = k[1].position.x, Ly = k[1].position.y;   // левый глаз
    const Rx = k[2].position.x, Ry = k[2].position.y;   // правый глаз
    noseX = lerp(noseX,nX,.5); noseY = lerp(noseY,nY,.5);
    leX   = lerp(leX  ,Lx,.5); leY   = lerp(leY  ,Ly,.5);
    reX   = lerp(reX  ,Rx,.5); reY   = lerp(reY  ,Ry,.5);
    const d = dist(noseX,noseY,leX,leY);
    mX = lerp(mX,nX,.5); mY = lerp(mY,nY + d,.5);      // рот ≈ нос + d вниз
  });
}

/* ============ безопасный кроп (из твоего кода) ============ */
function safeRect(sx,sy,sw,sh){
  const vw = video.width  || video.videoWidth  || 480;
  const vh = video.height || video.videoHeight || 640;
  const x = clamp(sx,0,vw-1), y = clamp(sy,0,vh-1);
  const w = clamp(sw,1,vw-x), h = clamp(sh,1,vh-y);
  return {x,y,w,h};
}

/* ============ рисование канвасов ============ */
function drawFull(dstCtx, dw, dh){
  try { dstCtx.drawImage(video, 0, 0, video.videoWidth||dw, video.videoHeight||dh, 0, 0, dw, dh); }
  catch(e){}
}
function drawCrop(dstCtx, b, dw, dh){
  if (!b || !Number.isFinite(b.x) || !Number.isFinite(b.y)) { drawFull(dstCtx, dw, dh); return; }
  const r = safeRect(b.x, b.y, b.w, b.h);
  try { dstCtx.drawImage(video, r.x, r.y, r.w, r.h, 0, 0, dw, dh); } catch(e){}
}

function drawFromTracking(){
  if (trackingMode === 'facemesh'){
    const has = LM.nose || LM.lEye || LM.rEye || LM.mouth;
    if (!has){
      // до первого предикта — льём полный кадр (кубы видны сразу)
      drawFull(ctxN, cNose.width,  cNose.height);
      drawFull(ctxL, cEyeL.width,  cEyeL.height);
      drawFull(ctxR, cEyeR.width,  cEyeR.height);
      drawFull(ctxM, cMouth.width, cMouth.height);
    } else {
      drawCrop(ctxN, LM.nose,  cNose.width,  cNose.height);
      drawCrop(ctxL, LM.lEye,  cEyeL.width,  cEyeL.height);
      drawCrop(ctxR, LM.rEye,  cEyeR.width,  cEyeR.height);
      drawCrop(ctxM, LM.mouth, cMouth.width, cMouth.height);
    }
  } else {
    // posenet (твоя логика)
    const d = dist(noseX,noseY,leX,leY) || 120;
    const parts = [
      {ctx:ctxN, x:noseX-d/2, y:noseY-d/2, w:d+0.01, h:d+0.01, dw:cNose.width,  dh:cNose.height},
      {ctx:ctxL, x:leX  -d/2, y:leY  -d/2, w:d+0.01, h:d+0.01, dw:cEyeL.width,  dh:cEyeL.height},
      {ctx:ctxR, x:reX  -d/2, y:reY  -d/2, w:d+0.01, h:d+0.01, dw:cEyeR.width,  dh:cEyeR.height},
      {ctx:ctxM, x:mX   -d/2, y:mY   -d/2, w:d+0.01, h:d+0.01, dw:cMouth.width, dh:cMouth.height},
    ];
    for (const p of parts){
      const r = safeRect(p.x,p.y,p.w,p.h);
      try { p.ctx.drawImage(video, r.x,r.y,r.w,r.h, 0,0, p.dw,p.dh); }
      catch(e){ drawFull(p.ctx, p.dw, p.dh); }
    }
  }
}

/* ============ основной цикл ============ */
function loop(){
  requestAnimationFrame(loop);

  drawFromTracking();

  // обновить текстуры
  if (texNose)  texNose.needsUpdate  = true;
  if (texEyeL)  texEyeL.needsUpdate  = true;
  if (texEyeR)  texEyeR.needsUpdate  = true;
  if (texMouth) texMouth.needsUpdate = true;

  if (renderer && camera && scene){
    camera.lookAt(scene.position);
    renderer.render(scene,camera);
    if (controls) controls.update();
  }
}

/* ============ boot ============ */
function boot(){
  initThree();
  // стартуем FaceMesh; если не поедет — авто-fallback в startFaceMesh
  trackingMode = 'facemesh';
  startFaceMesh();
  // страховка: если через 6с нет вообще предиктов — точно включаем posenet
  setTimeout(()=>{
    if (!firstPrediction && trackingMode==='facemesh'){
      console.warn('Нет трекинга >6s → принудительный PoseNet');
      trackingMode = 'posenet';
      startPoseNet();
    }
  }, 6000);
  loop();
}
</script>
</body>
</html>
