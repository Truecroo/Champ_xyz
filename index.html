<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Куб-селфи</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />

  <!-- jQuery -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

  <!-- THREE.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- ВНИМАНИЕ: OrbitControls убрали, чтобы не было ошибки конструктора -->

  <!-- TFJS + MediaPipe FaceMesh + ml5 -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
  <script src="https://unpkg.com/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

  <link rel="stylesheet" href="selfie.css" />
  <style>
    body { margin:0; background:#000; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #permission-screen { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:16px; background:#000; z-index:10; padding:24px; text-align:center; }
    #button_loader, .downloadButton, .questionButton { padding:10px 16px; border:1px solid #fff; background:transparent; color:#fff; border-radius:8px; }
    #container { position:fixed; inset:0; display:none; }
    #about { position:fixed; right:12px; bottom:12px; }
    #aboutText { display:none; position:fixed; right:12px; bottom:60px; width:260px; background:rgba(0,0,0,.7); padding:12px; border-radius:8px; }
    #download_div { position:fixed; left:12px; bottom:12px; display:none; }
    #discription { position:fixed; top:12px; left:12px; background:rgba(0,0,0,.35); padding:8px 10px; border-radius:8px; }
    #loading-screen { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:#000; z-index:9; }
    #loading_gif { width:120px; height:120px; opacity:.8; }
    video { opacity:0; width:0; height:0; position:absolute; left:-9999px; }
    canvas { image-rendering:auto; }
    a { color:#9ad1ff; }
  </style>
</head>

<body>

  <div id="loading-screen" class="wrapper">
    <img id="loading_gif" src="Loading_G.gif" alt="Загрузка…" />
  </div>

  <section id="permission-screen">
    <div id="loader">
      <strong>Нужно разрешение на камеру</strong><br />
      Нажми «Продолжить» и в диалоге браузера выбери «Разрешить».<br />
      Видео никуда не сохраняется.
    </div>
    <button id="button_loader">Продолжить</button>
    <div style="opacity:.6; font-size:13px;">
      Если видишь «доступ запрещён» — открой настройки сайта в адресной строке и разреши камеру.
    </div>
  </section>

  <div id="container"></div>

  <!-- Текстурные канвасы -->
  <canvas id="canvas04" width="512" height="512" style="display:none"></canvas>  <!-- нос -->
  <canvas id="canvas01" width="512" height="512" style="display:none"></canvas>  <!-- правый глаз -->
  <canvas id="canvas02" width="512" height="256" style="display:none"></canvas>  <!-- рот -->
  <canvas id="Mycanvas" width="512" height="512" style="display:none"></canvas>  <!-- левый глаз -->

  <!-- Скрытое видео -->
  <video autoplay muted playsinline id="video" width="480" height="640"></video>

  <div id="discription">тап — меняет композицию • свайп — меняет план</div>

  <div id="about">
    <div id="aboutText">
      <p class="explain"><b>Куб-селфи</b> — 3D + детекция лица. Управляй перспективой и находи лучший ракурс.</p>
      <p class="credits">
        Технологии: <a href="https://threejs.org/">Three.js</a> и <a href="https://learn.ml5js.org/#/reference/facemesh">ml5</a>
      </p>
    </div>
    <button class="questionButton" id="aboutButton">Инфо</button>
  </div>

  <div id="download_div">
    <button class="downloadButton" id="download">Сделать снимок</button>
  </div>

<script>
  // ===== DOM & helpers =====
  const video = document.getElementById("video");
  video.setAttribute('playsinline','true');
  video.setAttribute('muted','true');
  video.muted = true;
  video.addEventListener('loadedmetadata', () => {
    if (video.videoWidth && video.videoHeight) {
      video.width  = video.videoWidth;
      video.height = video.videoHeight;
    }
  });

  const nose_canvas  = document.getElementById("canvas04"); const ctxNose  = nose_canvas.getContext("2d");
  const left_canvas  = document.getElementById("Mycanvas"); const ctxLEye  = left_canvas.getContext("2d");
  const right_canvas = document.getElementById("canvas01"); const ctxREye  = right_canvas.getContext("2d");
  const mouth_canvas = document.getElementById("canvas02"); const ctxMouth = mouth_canvas.getContext("2d");

  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));

  // ===== Three.js =====
  let scene, renderer;
  let camera, orthoCamera, activeCamera, isOrtho = false;
  let cube01, cube02, cube03, cube04; // нос, левый глаз, правый глаз, рот
  const FIXED_Z = 0;

  const presets = [
    { nose:[   0,  -60], lEye:[ -70, -20], rEye:[  70, -20], mouth:[   0,  70] },
    { nose:[ -30,  -80], lEye:[ -90,  10], rEye:[  40,  30], mouth:[ -10,  90] },
    { nose:[  25,  -90], lEye:[ -50, -10], rEye:[  60,  40], mouth:[ -20, 100] }
  ];
  let presetIndex = 0;

  // ===== Лендмарки/боксы =====
  let firstPredictionCame = false;
  window._bbNose = null; window._bbLEye = null; window._bbREye = null; window._bbMouth = null;
  let noseX=0, noseY=0, leX=0, leY=0, reX=0, reY=0, mX=0, mY=0;

  // ===== UI =====
  $("#download").on("click", function(){
    const dataURL = renderer.domElement.toDataURL("image/png");
    const link = document.createElement("a");
    link.download = "selfie.png"; link.href = dataURL; link.target = "_blank"; link.click();
  });
  $("#aboutButton").on("click", function(){
    $("#aboutText").fadeToggle('fast');
    $("#aboutButton").text(($("#aboutButton").text() === 'Инфо') ? 'Закрыть' : 'Инфо').fadeIn();
  });
  $("#container, #discription").on('touchstart mousedown', function(){ $("#discription").fadeOut('fast'); });

  // ===== Камера + ошибки =====
  async function askCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio:false });
      video.srcObject = stream;
      await video.play();
      return true;
    } catch (err) {
      console.error('[getUserMedia error]', err.name, err.message);
      const hints = {
        NotAllowedError:    'Доступ к камере запрещён для этого сайта. Разреши камеру в настройках сайта и перезагрузи страницу.',
        NotFoundError:      'Камера не найдена. Подключи камеру или выбери её в настройках системы/браузера.',
        NotReadableError:   'Камера занята другим приложением. Закрой приложения, использующие камеру, и попробуй снова.',
        OverconstrainedError:'Выбранные параметры камеры недоступны. Попробуй стандартный режим.',
        SecurityError:      'Нужен HTTPS (или http://localhost).',
        TypeError:          'Неверные параметры запроса к камере.'
      };
      alert(hints[err.name] || ('Ошибка камеры: ' + err.message));
      return false;
    }
  }

  // ===== Кнопка «Продолжить» =====
  $("#button_loader").on("click", async function(){
    $("#permission-screen").fadeOut('slow');
    $("#loading-screen").show();

    const ok = await askCamera();
    if (!ok) { $("#loading-screen").hide(); $("#permission-screen").show(); return; }

    $("#container").fadeIn('slow');
    $("#download_div").fadeIn('slow');
    $("#aboutButton").fadeIn('slow');
    $("#loading-screen").fadeOut('fast');

    bootML();   // FaceMesh + PoseNet
    initThree();
    animate();
  });

  // ===== Инициализация моделей =====
  function bootML(){
    // FaceMesh
    try {
      const fm = ml5.faceMesh(video, () => console.log('FaceMesh готов'));
      fm.on('predict', gotFaces);
    } catch(e) { console.warn('FaceMesh не запустился:', e); }

    // PoseNet — бэкап
    try {
      const net = ml5.poseNet(video, () => console.log('PoseNet готов'));
      net.on('pose', gotPoses);
    } catch(e) { console.warn('PoseNet не запустился:', e); }
  }

  // FaceMesh → bbox
  function gotFaces(results){
    if (!results || !results.length) return;
    firstPredictionCame = true;
    const pts = results[0].scaledMesh;
    const leftEyeIdx = [33,133,160,159,158,157,173];
    const rightEyeIdx= [362,263,387,386,385,384,398];
    const noseIdx    = [1,6,197,195,5,4,45];
    const mouthIdx   = [78,95,88,178,87,14,317,308,324];

    function bbox(idxs){
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for(const i of idxs){ const p=pts[i]; if(!p) continue; const x=p[0],y=p[1];
        if(x<minX) minX=x; if(y<minY) minY=y; if(x>maxX) maxX=x; if(y>maxY) maxY=y; }
      return {x:minX,y:minY,w:Math.max(1,maxX-minX),h:Math.max(1,maxY-minY)};
    }
    function pad(b,p=10){ return {x:b.x-p,y:b.y-p,w:b.w+2*p,h:b.h+2*p}; }

    window._bbNose  = pad(bbox(noseIdx), 10);
    window._bbLEye  = pad(bbox(leftEyeIdx), 10);
    window._bbREye  = pad(bbox(rightEyeIdx), 10);
    window._bbMouth = pad(bbox(mouthIdx), 12);
  }

  // PoseNet → fallback боксы
  function gotPoses(res){
    if (!res || !res.length) return;
    const k = res[0].pose.keypoints;
    const nX = k[0].position.x, nY = k[0].position.y;
    const Lx = k[1].position.x, Ly = k[1].position.y;
    const Rx = k[2].position.x, Ry = k[2].position.y;

    const lerp=(a,b,t)=>a+(b-a)*Math.max(0,Math.min(1,t));
    noseX = lerp(noseX,nX,.5); noseY = lerp(noseY,nY,.5);
    leX   = lerp(leX  ,Lx,.5); leY   = lerp(leY  ,Ly,.5);
    reX   = lerp(reX  ,Rx,.5); reY   = lerp(reY  ,Ry,.5);

    const d = Math.hypot(noseX-leX, noseY-leY) || 120;
    mX = lerp(mX,noseX,.5); mY = lerp(mY,noseY + d,.5);

    const makeBox=(cx,cy,sz)=>({x:cx-sz/2, y:cy-sz/2, w:sz, h:sz});
    const sz = Math.max(40, Math.min(300, d));
    window._bbNose  = makeBox(noseX, noseY, sz);
    window._bbLEye  = makeBox(leX,   leY,   sz);
    window._bbREye  = makeBox(reX,   reY,   sz);
    window._bbMouth = { x:mX - sz/2, y:mY - sz/2, w:sz, h:sz*0.5 };
  }

  // ===== Three setup (без OrbitControls) =====
  function initThree(){
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0b0b);

    renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    const aspect = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(35, aspect, 0.1, 2000);
    camera.position.set(0,0,300);

    const frustumSize = 400;
    orthoCamera = new THREE.OrthographicCamera(
      -frustumSize*aspect/2, frustumSize*aspect/2,
       frustumSize/2, -frustumSize/2,
       0.1, 2000
    );
    orthoCamera.position.set(0,0,300);
    activeCamera = camera;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(300, 400, 500); scene.add(dir);

    const texNose  = new THREE.CanvasTexture(nose_canvas);
    const texLEye  = new THREE.CanvasTexture(left_canvas);
    const texREye  = new THREE.CanvasTexture(right_canvas);
    const texMouth = new THREE.CanvasTexture(mouth_canvas);

    cube01 = new THREE.Mesh(new THREE.BoxGeometry(70, 90, 70),  new THREE.MeshBasicMaterial({ map: texNose  }));
    cube02 = new THREE.Mesh(new THREE.BoxGeometry(60, 60, 60),  new THREE.MeshBasicMaterial({ map: texLEye  }));
    cube03 = new THREE.Mesh(new THREE.BoxGeometry(60, 60, 60),  new THREE.MeshBasicMaterial({ map: texREye  }));
    cube04 = new THREE.Mesh(new THREE.BoxGeometry(120,55, 55),  new THREE.MeshBasicMaterial({ map: texMouth }));

    [cube01, cube02, cube03, cube04].forEach(c=>{ c.rotation.set(0,0,0); c.position.z = FIXED_Z; scene.add(c); });
    applyPreset(presetIndex);

    window.addEventListener('resize', onResize);

    // Жесты: тап/свайп
    let drag=false, startX=0;
    document.addEventListener('pointerdown', e=>{ drag=false; startX=e.clientX; }, {passive:true});
    document.addEventListener('pointermove', ()=>{ drag=true; }, {passive:true});
    document.addEventListener('pointerup', e=>{
      if(!drag){ onTap(e); return; }
      const dx = e.clientX - startX; if (Math.abs(dx)>40) togglePlan(dx);
    }, {passive:true});
  }

  function applyPreset(i){
    const p = presets[i];
    cube01.position.set(p.nose[0],  p.nose[1],  FIXED_Z);
    cube02.position.set(p.lEye[0],  p.lEye[1],  FIXED_Z);
    cube03.position.set(p.rEye[0],  p.rEye[1],  FIXED_Z);
    cube04.position.set(p.mouth[0], p.mouth[1], FIXED_Z);
    [cube01, cube02, cube03, cube04].forEach(c=>c.rotation.set(0,0,0));
  }

  function onResize(){
    const w = window.innerWidth, h = window.innerHeight, aspect = w/h;
    camera.aspect = aspect; camera.updateProjectionMatrix();

    const frustumSize = 400;
    orthoCamera.left = -frustumSize*aspect/2;
    orthoCamera.right =  frustumSize*aspect/2;
    orthoCamera.top =    frustumSize/2;
    orthoCamera.bottom = -frustumSize/2;
    orthoCamera.updateProjectionMatrix();

    renderer.setSize(w,h);
  }

  function onTap(e){
    const downloadRect = document.getElementById("download_div").getBoundingClientRect();
    const aboutRect    = document.getElementById("aboutButton").getBoundingClientRect();
    const x = e.pageX || e.clientX, y = e.pageY || e.clientY;
    const inDownload = x >= downloadRect.left-5 && x <= downloadRect.right+5 &&
                       y >= downloadRect.top-5  && y <= downloadRect.bottom+5;
    const inAbout    = x >= aboutRect.left-5    && x <= aboutRect.right+5 &&
                       y >= aboutRect.top-5     && y <= aboutRect.bottom+5;
    if (inDownload || inAbout) return;
    presetIndex = (presetIndex + 1) % presets.length;
    applyPreset(presetIndex);
  }

  function togglePlan(dx){
    isOrtho = !isOrtho;
    activeCamera = isOrtho ? orthoCamera : camera;
    const dir = dx > 0 ? 1 : -1;
    scene.rotation.y += dir * 0.15;
  }

  // ===== Рендер/нарезка =====
  function drawFull(dstCtx, dw, dh){
    try { dstCtx.drawImage(video, 0, 0, video.videoWidth||dw, video.videoHeight||dh, 0, 0, dw, dh); }
    catch(e){}
  }
  function drawCrop(dstCtx, b, dw, dh){
    if (!b || !Number.isFinite(b.x) || !Number.isFinite(b.y)) { drawFull(dstCtx, dw, dh); return; }
    const vw = video.videoWidth || video.width || 480;
    const vh = video.videoHeight || video.height || 640;
    const sx = clamp(b.x, 0, vw-1);
    const sy = clamp(b.y, 0, vh-1);
    const sw = clamp(b.w, 1, vw - sx);
    const sh = clamp(b.h, 1, vh - sy);
    try { dstCtx.drawImage(video, sx, sy, sw, sh, 0, 0, dw, dh); } catch(e){}
  }

  function animate(){
    requestAnimationFrame(animate);

    const hasLM = (_bbNose || _bbLEye || _bbREye || _bbMouth);
    if (hasLM) {
      drawCrop(ctxNose,  _bbNose,  nose_canvas.width,  nose_canvas.height);
      drawCrop(ctxLEye,  _bbLEye,  left_canvas.width,  left_canvas.height);
      drawCrop(ctxREye,  _bbREye,  right_canvas.width, right_canvas.height);
      drawCrop(ctxMouth, _bbMouth, mouth_canvas.width, mouth_canvas.height);
    } else {
      drawFull(ctxNose,  nose_canvas.width,  nose_canvas.height);
      drawFull(ctxLEye,  left_canvas.width,  left_canvas.height);
      drawFull(ctxREye,  right_canvas.width, right_canvas.height);
      drawFull(ctxMouth, mouth_canvas.width, mouth_canvas.height);
    }

    if (cube01?.material?.map) cube01.material.map.needsUpdate = true;
    if (cube02?.material?.map) cube02.material.map.needsUpdate = true;
    if (cube03?.material?.map) cube03.material.map.needsUpdate = true;
    if (cube04?.material?.map) cube04.material.map.needsUpdate = true;

    activeCamera.lookAt(scene.position);
    renderer.render(scene, activeCamera);
  }
</script>
</body>
</html>
