<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Куб-селфи</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

  <!-- THREE.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js"></script>

  <!-- TFJS + MediaPipe FaceMesh + ml5 -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js"></script>
  <script src="https://unpkg.com/@mediapipe/face_mesh@0.4/face_mesh.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

  <link rel="stylesheet" href="selfie.css" />
  <style>
    body { margin:0; background:#000; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #permission-screen { position:fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:16px; background:#000; z-index:10; padding:24px; text-align:center; }
    #button_loader, .downloadButton, .questionButton { padding:10px 16px; border:1px solid #fff; background:transparent; color:#fff; border-radius:8px; }
    #container { position:fixed; inset:0; display:none; }
    #about { position:fixed; right:12px; bottom:12px; }
    #aboutText { display:none; position:fixed; right:12px; bottom:60px; width:260px; background:rgba(0,0,0,.7); padding:12px; border-radius:8px; }
    #download_div { position:fixed; left:12px; bottom:12px; display:none; }
    #discription { position:fixed; top:12px; left:12px; background:rgba(0,0,0,.35); padding:8px 10px; border-radius:8px; }
    #frame { position:fixed; top:12px; right:12px; display:none; }
    #loading-screen { position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:#000; z-index:9; }
    #loading_gif { width:120px; height:120px; opacity:.8; }
    video { opacity:0; width:0; height:0; position:absolute; left:-9999px; }
    canvas { image-rendering:auto; }
    a { color:#9ad1ff; }
  </style>
</head>

<body>
  <div id="loading-screen" class="wrapper">
    <img id="loading_gif" src="Loading_G.gif" alt="Загрузка…" />
  </div>

  <section id="permission-screen">
    <div id="loader">
      <strong>Нужно разрешение на камеру</strong><br />
      Нажми «Продолжить» и в диалоге браузера выбери «Разрешить».<br />
      Видео никуда не сохраняется.
    </div>
    <button id="button_loader">Продолжить</button>
    <div style="opacity:.6; font-size:13px;">
      Если видишь «доступ запрещён» — открой настройки сайта в адресной строке и разреши камеру.
    </div>
  </section>

  <div id="container"></div>

  <!-- Канвасы под текстуры -->
  <canvas id="canvas04" width="512" height="512" style="display:none"></canvas>  <!-- нос -->
  <canvas id="canvas01" width="512" height="512" style="display:none"></canvas>  <!-- правый глаз -->
  <canvas id="canvas02" width="512" height="256" style="display:none"></canvas>  <!-- рот -->
  <canvas id="Mycanvas" width="512" height="512" style="display:none"></canvas>  <!-- левый глаз -->

  <video autoplay muted playsinline id="video" width="480" height="640"></video>

  <div id="discription">тап — меняет композицию • свайп — меняет план</div>
  <div id="frame"><p class="desktop_view">Проект лучше смотреть на телефоне</p></div>

  <div id="about">
    <div id="aboutText">
      <p class="explain"><b>Куб-селфи</b> — эксперимент с 3D и детекцией лица. Управляй перспективой и находи лучший ракурс.</p>
      <p class="credits">
        Технологии: <a href="https://threejs.org/">Three.js</a> и <a href="https://learn.ml5js.org/#/reference/facemesh">ml5 FaceMesh</a>
      </p>
    </div>
    <button class="questionButton" id="aboutButton">Инфо</button>
  </div>

  <div id="download_div">
    <button class="downloadButton" id="download">Сделать снимок</button>
  </div>

<script>
  // ===== DOM =====
  const video = document.getElementById("video");
  video.setAttribute('playsinline','true');
  video.setAttribute('muted','true');
  video.muted = true;
  video.addEventListener('loadedmetadata', () => {
    if (video.videoWidth && video.videoHeight) {
      video.width  = video.videoWidth;
      video.height = video.videoHeight;
    }
  });

  const nose_canvas  = document.getElementById("canvas04"); const ctxNose  = nose_canvas.getContext("2d");
  const left_canvas  = document.getElementById("Mycanvas"); const ctxLEye  = left_canvas.getContext("2d");
  const right_canvas = document.getElementById("canvas01"); const ctxREye  = right_canvas.getContext("2d");
  const mouth_canvas = document.getElementById("canvas02"); const ctxMouth = mouth_canvas.getContext("2d");

  // ===== Three.js =====
  let scene, renderer, controls;
  let camera, orthoCamera, activeCamera, isOrtho = false;
  let cube01, cube02, cube03, cube04; // нос, левый, правый, рот
  const FIXED_Z = 0;

  // Пресеты (централизовал ближе к (0,0), чтобы точно были в кадре)
  const presets = [
    { nose:[   0,  -60], lEye:[ -70, -20], rEye:[  70, -20], mouth:[   0,  70] },
    { nose:[ -30,  -80], lEye:[ -90,  10], rEye:[  40,  30], mouth:[ -10,  90] },
    { nose:[  25,  -90], lEye:[ -50, -10], rEye:[  60,  40], mouth:[ -20, 100] }
  ];
  let presetIndex = 0;

  // bbox (обновляются по FaceMesh)
  window._bbNose = null;
  window._bbLEye = null;
  window._bbREye = null;
  window._bbMouth = null;

  // ===== Жесты =====
  let drag = false, touchStartX = 0, touchStartY = 0;

  // ===== UI =====
  $("#download").on("click", function(){
    const dataURL = renderer.domElement.toDataURL("image/png");
    const link = document.createElement("a");
    link.download = "selfie.png";
    link.href = dataURL;
    link.target = "_blank";
    link.click();
  });

  $("#aboutButton").on("click", function(){
    $("#aboutText").fadeToggle('fast');
    $("#aboutButton").text(($("#aboutButton").text() === 'Инфо') ? 'Закрыть' : 'Инфо').fadeIn();
  });

  $("#container, #discription").on('touchstart mousedown', function(){ $("#discription").fadeOut('fast'); });

  // ===== Камера с хэндлером ошибок =====
  async function askCamera() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio:false });
      video.srcObject = stream;
      await video.play();
      return true;
    } catch (err) {
      console.error('[getUserMedia error]', err.name, err.message);
      const hints = {
        NotAllowedError:    'Доступ к камере запрещён для этого сайта. Разреши камеру в настройках сайта и перезагрузи страницу.',
        NotFoundError:      'Камера не найдена. Подключи камеру или выбери её в настройках системы/браузера.',
        NotReadableError:   'Камера занята другим приложением. Закрой приложения, использующие камеру, и попробуй снова.',
        OverconstrainedError:'Выбранные параметры камеры недоступны. Попробуй стандартный режим.',
        SecurityError:      'Страница должна быть открыта по HTTPS (или на http://localhost). Проверь адрес.',
        TypeError:          'Неверные параметры запроса к камере. Обнови страницу и попробуй ещё раз.'
      };
      alert(hints[err.name] || ('Ошибка камеры: ' + err.message));
      return false;
    }
  }

  // ===== Кнопка «Продолжить» =====
  let faceMesh, firstPredictionCame = false;
  $("#button_loader").on("click", async function(){
    $("#permission-screen").fadeOut('slow');
    $("#loading-screen").show();

    const ok = await askCamera();
    if (!ok) {
      $("#loading-screen").hide();
      $("#permission-screen").show();
      return;
    }

    // Видео уже играет — показываем сцену и скрываем лоадер
    $("#container").fadeIn('slow');
    $("#download_div").fadeIn('slow');
    $("#aboutButton").fadeIn('slow');
    $("#loading-screen").fadeOut('fast');

    // Инициализируем FaceMesh (не блокируя UI)
    try {
      if (!ml5 || !ml5.faceMesh) throw new Error("ml5.faceMesh недоступен");
      faceMesh = ml5.faceMesh(video, () => console.log("FaceMesh готов"));
      faceMesh.on("predict", gotFaces);
    } catch (e) {
      console.warn("FaceMesh не инициализировался:", e);
    }

    // Форс-таймер: если нет ни одного предикта >5с — работаем с полным кадром
    setTimeout(() => {
      if (!firstPredictionCame) console.warn("Нет предиктов FaceMesh >5с. Работаем на полном кадре.");
    }, 5000);
  });

  // ===== FaceMesh → bbox =====
  function gotFaces(results) {
    if (!results || results.length === 0) return;
    if (!firstPredictionCame) firstPredictionCame = true;

    const pts = results[0].scaledMesh;
    const leftEyeIdx = [33,133,160,159,158,157,173];
    const rightEyeIdx= [362,263,387,386,385,384,398];
    const noseIdx    = [1,6,197,195,5,4,45];
    const mouthIdx   = [78,95,88,178,87,14,317,308,324];

    function bbox(idxs){
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for(const i of idxs){ const p=pts[i]; if(!p) continue; const x=p[0],y=p[1];
        if(x<minX) minX=x; if(y<minY) minY=y; if(x>maxX) maxX=x; if(y>maxY) maxY=y; }
      return {x:minX,y:minY,w:Math.max(1,maxX-minX),h:Math.max(1,maxY-minY)};
    }
    function pad(b,p=10){ return {x:b.x-p,y:b.y-p,w:b.w+2*p,h:b.h+2*p}; }

    window._bbNose  = pad(bbox(noseIdx), 10);
    window._bbLEye  = pad(bbox(leftEyeIdx), 10);
    window._bbREye  = pad(bbox(rightEyeIdx), 10);
    window._bbMouth = pad(bbox(mouthIdx), 12);
  }

  // ===== Three.js init =====
  const VIEW_ANGLE = 35, NEAR = 0.1, FAR = 2000;
  initThree();
  animate();

  function initThree(){
    scene = new THREE.Scene();
    // слегка серый фон, чтобы кубы на старте были виднее
    scene.background = new THREE.Color(0x0b0b0b);

    renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('container').appendChild(renderer.domElement);

    // камеры
    const aspect = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(VIEW_ANGLE, aspect, NEAR, FAR);
    camera.position.set(0,0,300);

    const frustumSize = 400;
    orthoCamera = new THREE.OrthographicCamera(
      -frustumSize*aspect/2, frustumSize*aspect/2,
       frustumSize/2, -frustumSize/2,
       NEAR, FAR
    );
    orthoCamera.position.set(0,0,300);

    activeCamera = camera;

    controls = new THREE.OrbitControls(activeCamera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.enableRotate = false;

    // свет: добавил слабый Ambient, чтобы кубы не терялись
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(300, 400, 500);
    scene.add(dir);

    // текстуры
    const texNose  = new THREE.CanvasTexture(nose_canvas);
    const texLEye  = new THREE.CanvasTexture(left_canvas);
    const texREye  = new THREE.CanvasTexture(right_canvas);
    const texMouth = new THREE.CanvasTexture(mouth_canvas);

    const matNose  = new THREE.MeshBasicMaterial({ map: texNose  });
    const matLEye  = new THREE.MeshBasicMaterial({ map: texLEye  });
    const matREye  = new THREE.MeshBasicMaterial({ map: texREye  });
    const matMouth = new THREE.MeshBasicMaterial({ map: texMouth });

    const gNose  = new THREE.BoxGeometry(70, 90, 70);
    const gEye   = new THREE.BoxGeometry(60, 60, 60);
    const gMouth = new THREE.BoxGeometry(120, 55, 55);

    cube01 = new THREE.Mesh(gNose,  matNose);   // нос
    cube02 = new THREE.Mesh(gEye,   matLEye);   // левый глаз
    cube03 = new THREE.Mesh(gEye,   matREye);   // правый глаз
    cube04 = new THREE.Mesh(gMouth, matMouth);  // рот

    [cube01, cube02, cube03, cube04].forEach(c=>{
      c.rotation.set(0,0,0);
      c.position.z = FIXED_Z;
      scene.add(c);
    });

    applyPreset(presetIndex);
    window.addEventListener('resize', onResize);
  }

  function applyPreset(i){
    const p = presets[i];
    cube01.position.set(p.nose[0],  p.nose[1],  FIXED_Z);
    cube02.position.set(p.lEye[0],  p.lEye[1],  FIXED_Z);
    cube03.position.set(p.rEye[0],  p.rEye[1],  FIXED_Z);
    cube04.position.set(p.mouth[0], p.mouth[1], FIXED_Z);
    [cube01, cube02, cube03, cube04].forEach(c=>c.rotation.set(0,0,0));
  }

  function onResize(){
    const w = window.innerWidth, h = window.innerHeight, aspect = w/h;
    camera.aspect = aspect; camera.updateProjectionMatrix();

    const frustumSize = 400;
    orthoCamera.left = -frustumSize*aspect/2;
    orthoCamera.right =  frustumSize*aspect/2;
    orthoCamera.top =    frustumSize/2;
    orthoCamera.bottom = -frustumSize/2;
    orthoCamera.updateProjectionMatrix();

    renderer.setSize(w,h);
  }

  // ===== Рендер из видео в канвасы =====
  function drawFull(dstCtx, dw, dh){
    try { dstCtx.drawImage(video, 0, 0, video.videoWidth||dw, video.videoHeight||dh, 0, 0, dw, dh); }
    catch(e){}
  }
  function drawCrop(dstCtx, b, dw, dh){
    if (!b || !Number.isFinite(b.x) || !Number.isFinite(b.y)) { drawFull(dstCtx, dw, dh); return; }
    const sx = Math.max(0, b.x), sy = Math.max(0, b.y);
    const sw = Math.max(1, b.w), sh = Math.max(1, b.h);
    try { dstCtx.drawImage(video, sx, sy, sw, sh, 0, 0, dw, dh); } catch(e){}
  }

  // ===== Жесты: тап / свайп =====
  document.addEventListener('pointerdown', ()=>{ drag=false; }, {passive:true});
  document.addEventListener('pointermove',  ()=>{ drag=true;  }, {passive:true});
  document.addEventListener('pointerup',    (e)=>{ if(!drag) onTap(e); }, {passive:true});

  document.addEventListener('touchstart', (e)=>{
    drag=false;
    const t = e.touches[0];
    touchStartX = t.clientX; touchStartY = t.clientY;
  }, {passive:true});
  document.addEventListener('touchmove', ()=>{ drag=true; }, {passive:true});
  document.addEventListener('touchend', (e)=>{
    if(!drag){ onTap(e.changedTouches ? e.changedTouches[0] : e); return; }
    const dx = (e.changedTouches[0].clientX - touchStartX);
    if(Math.abs(dx)>40) togglePlan(dx);
  }, {passive:true});

  function onTap(e){
    const downloadRect = document.getElementById("download_div").getBoundingClientRect();
    const aboutRect    = document.getElementById("aboutButton").getBoundingClientRect();
    const x = e.pageX || e.clientX, y = e.pageY || e.clientY;
    const inDownload = x >= downloadRect.left-5 && x <= downloadRect.right+5 &&
                       y >= downloadRect.top-5  && y <= downloadRect.bottom+5;
    const inAbout    = x >= aboutRect.left-5    && x <= aboutRect.right+5 &&
                       y >= aboutRect.top-5     && y <= aboutRect.bottom+5;
    if (inDownload || inAbout) return;

    presetIndex = (presetIndex + 1) % presets.length;
    applyPreset(presetIndex);
  }

  function togglePlan(dx){
    isOrtho = !isOrtho;
    activeCamera = isOrtho ? orthoCamera : camera;
    const dir = dx > 0 ? 1 : -1;
    scene.rotation.y += dir * 0.15;
  }

  // ===== Главный цикл =====
  function animate(){
    requestAnimationFrame(animate);

    // пока нет лендмарок — рисуем ПОЛНЫЙ кадр (чтобы кубы сразу были видны)
    const hasLM = !!(window._bbNose || window._bbLEye || window._bbREye || window._bbMouth);
    if (hasLM) {
      drawCrop(ctxNose,  window._bbNose,  nose_canvas.width,  nose_canvas.height);
      drawCrop(ctxLEye,  window._bbLEye,  left_canvas.width,  left_canvas.height);
      drawCrop(ctxREye,  window._bbREye,  right_canvas.width, right_canvas.height);
      drawCrop(ctxMouth, window._bbMouth, mouth_canvas.width, mouth_canvas.height);
    } else {
      drawFull(ctxNose,  nose_canvas.width,  nose_canvas.height);
      drawFull(ctxLEye,  left_canvas.width,  left_canvas.height);
      drawFull(ctxREye,  right_canvas.width, right_canvas.height);
      drawFull(ctxMouth, mouth_canvas.width, mouth_canvas.height);
    }

    if (cube01?.material?.map) cube01.material.map.needsUpdate = true;
    if (cube02?.material?.map) cube02.material.map.needsUpdate = true;
    if (cube03?.material?.map) cube03.material.map.needsUpdate = true;
    if (cube04?.material?.map) cube04.material.map.needsUpdate = true;

    activeCamera.lookAt(scene.position);
    renderer.render(scene, activeCamera);
  }
</script>
</body>
</html>
